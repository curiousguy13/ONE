/* 
 * Copyright 2010 Aalto University, ComNet
 * Released under GPLv3. See LICENSE.txt for details. 
 */
package routing;

import org.jblas.*;
import org.shogun.*;

import java.util.Arrays;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import routing.util.RoutingInfo;

import util.Tuple;

import core.Coord;
import core.Connection;
import core.DTNHost;
import core.Message;
import core.Settings;
import core.SimClock;


/**
 * Implementation of Game router as described in 
 * <I>Probabilistic routing in intermittently connected networks</I> by
 * Anders Lindgren et al.
 */
public class KMeansRouter extends ActiveRouter{


   private static int start=0; // Transferring messages when start=1
   private static int nodeCount=-1; //to store the count of no of nodes 
   private double zerothreshold; //to check how much of the encounter matrix has been filled

   public static final double DEFAULT_ZEROTHRESHOLD=0.25;
   
   public static final String edMulti_NS = "KMeansRouter";
    
   private double maxPossibleZeroes=nodeCount*nodeCount*zerothreshold;

   public static final String ZEROTHRESHOLD_S = "zerothreshold";
   
	/** number of encounters of every node with every other node*/
	private static int[][] encounters;

	/** sumEncounters of total encounters by every node*/
	private static Map<DTNHost, Integer> sumEncounters;
	
	

	/**
	 * Constructor. Creates a new message router based on the settings in
	 * the given Settings object.
	 * @param s The settings object
	 */
	public KMeansRouter(Settings s) {
		super(s);
		Settings edMultiSettings = new Settings(edMulti_NS);
		
		if (edMultiSettings.contains(ZEROTHRESHOLD_S)) {
			zerothreshold = edMultiSettings.getDouble(ZEROTHRESHOLD_S);
		}
		else {
			zerothreshold = DEFAULT_ZEROTHRESHOLD;
		}
	}

	/**
	 * Copyconstructor.
	 * @param r The router prototype where setting values are copied from
	 */
	protected KMeansRouter(KMeansRouter r) {
		super(r);
		this.zerothreshold=r.zerothreshold;
	}
	
	 void checkStart()  {   
	
		int countZeroes=0;
	
		int i,j;
	
		for(i=0;i<nodeCount;i++) {
	    	for(j=0;j<nodeCount;j++) {
	       		if(encounters[i][j]==0){
	       	   		countZeroes++;
	        	}
	    	}
		}
	    if(countZeroes < maxPossibleZeroes)
	    {
	        start=1; //set start to 1 if the encounter matrix satisfies threshold for no of zero values
	    }
	    
	    return;
	    
	}   //end of checkStart 
	
	
	/*//Function to find the squarred distance between two points
   private double findDistance(double x1, double y1, double k[2]) {
    
    double dist = java.lang.Math.pow((k[0]-x1),2) + java.lang.Math.pow((k[1]-y1),2) ;
    return dist;
    
    }  */
	
	
	@Override
	public void changedConnection(Connection con) {
		super.changedConnection(con);
		
		if (con.isUp()) {
			DTNHost otherHost = con.getOtherNode(getHost());
			
			if(nodeCount==-1)
			{
				nodeCount=otherHost.getHosts().size();
				maxPossibleZeroes=nodeCount*nodeCount*zerothreshold;
			}
			
			updateEncounters(getHost(),otherHost);
			//to set start
		 	if(start==0) { 
				checkStart();
			}  
		
		}
	}
	

	/**
	 * Updates the value of encounters when two nodes come in contact with each other
	 * @param host1 first node
	 * @param host2 second node
	 */
	public void updateEncounters(DTNHost host1, DTNHost host2) {
		//each message has different destination and we'll need encounters of every node with the destination(which is changing with each message) in same time instance, hence we've decided to use a 2D array
		if (this.encounters == null) {
			this.encounters=new int[host1.getHosts().size()][host1.getHosts().size()]; 
		}
		if(this.sumEncounters == null){
			this.sumEncounters=new HashMap<DTNHost, Integer>();
		}
		KMeansRouter othRouter = (KMeansRouter)host2.getRouter();
		KMeansRouter myRouter = (KMeansRouter)host1.getRouter();

		//if sumEncounters does not contain host1 , put host1 in sumEncounters and initialise by 0
		if(!this.sumEncounters.containsKey(host1))
		{
			sumEncounters.put(host1,0);
		}
		//if sumEncounters does not contain host2 , put hostin sumEncounters and initialise by 0
		if(!this.sumEncounters.containsKey(host2))
		{
			sumEncounters.put(host2,0);
		}
		if(myRouter!=othRouter)
		{
			this.encounters[host1.getAddress()][host2.getAddress()]++;

			//increase the value of sumEncounters of host1 by 1 
			this.sumEncounters.put(host1,this.sumEncounters.get(host1)+1);
		}
		else
		{
			this.encounters[host1.getAddress()][host2.getAddress()]++;
			this.encounters[host2.getAddress()][host1.getAddress()]++;
			this.sumEncounters.put(host1,this.sumEncounters.get(host1)+1);
			this.sumEncounters.put(host2,this.sumEncounters.get(host2)+1);
		}
		
	}

	/**
	 * Returns the current encounter (E) value for a host
	 * @param host1 The host to look the E for
	 * @param host2 The node with respect to which we have to return the encounters
	 * @return the current E value
	 */
	public int getEncounter(DTNHost host1,DTNHost host2){
		return this.encounters[host1.getAddress()][host2.getAddress()];
	}

	
	
	@Override
	public void update() {
		super.update();
		if (!canStartTransfer() ||isTransferring()) {
			return; // nothing to transfer or is currently transferring 
		}
		
		// try messages that could be delivered to final recipient
		if (exchangeDeliverableMessages() != null) {
			return;
		}

		
		//To begin simulation when start=1
        //i.e. when the encounter matrix has no zero value
		 if(start==1)
		{
			tryOtherMessages();	
		}	 
		
		
	}
	
	/**
	 * Tries to send all other messages to all connected hosts
	 * @return The return value of {@link #tryMessagesForConnected(List)}
	 */
	private Tuple<Message, Connection> tryOtherMessages() {
		List<Tuple<Message, Connection>> messages = 
			new ArrayList<Tuple<Message, Connection>>(); 
	
		Collection<Message> msgCollection = getMessageCollection();

		
		for(Message m : msgCollection){

			//Map<DTNHost, Double> bestGammaWorld = new HashMap<DTNHost, Double>();

			Map<DTNHost, Double> bestGammaLocal = new HashMap<DTNHost, Double>();

			DTNHost dest = m.getTo();

			int count=0;
	        double enc; double distance, meanDistance, meanEncounter; double sumDistance=0, sumEncounter=0; 
		    int noOfFeatures=2; int cons=0;
		    
		    int i=0;
				
				
			 double[][] training_set = new double[getConnections().size()][noOfFeatures];
			
			
			for (Connection con : getConnections()){

				DTNHost me = getHost();
				DTNHost other = con.getOtherNode(getHost());
				KMeansRouter othRouter = (KMeansRouter)other.getRouter();
				
				
				enc= getEncounter(dest,other);
				distance=getDistFor(dest,other);
				
				training_set[cons][0]=(double)enc;
				sumEncounter+= (double)enc;
				training_set[cons][1]=distance;
				sumDistance+= distance;
				cons++;
				//Calculate other features and then plot their coordinates
				
                //In this for loop itself, we will be able to create our dataset like we just calculated
                //encounter and distance
                
                //for(i=0;i<cons;i++)
                //System.out.println(Arrays.toString(training_set[i][]));
                }
                
			meanDistance = sumDistance/cons ;
			meanEncounter = sumEncounter/cons ; 
			
			//mean normalizing encounters
			/*for(int i=0;i<cons;i++)
			    training_set[i][1] = (training_set[i][1] - meanDistance ) /cons ;
			  
			//mean normalizing distance    
			for(int i=0;i<cons;i++)
			    training_set[i][0] = (training_set[i][0] - meanEncounter ) /cons ;
			    
		       //Declaring two centroids
			double[] k1 = new double[noOfFeatures];
			double[] k2 = new double[noOfFeatures];
			
			//the centroids have been chosen as the first and the last data elements in the matrix
			for(int i=0;i<noOfFeatures;i++)
			    k1[i]=training_set[0][i];
			    
			for(int i=0;i<noOfFeatures;i++)
			    k2[i]=training_set[cons-1][i];
			    
			
			
			//printing out the two centroids chosen
			System.out.print(Arrays.toString(k1));
            System.out.print(Arrays.toString(k2) + " ");
            System.out.print("\n");
            
            findDistance(training_set[0][0], training_set[0][1], k2) */
			
			
			/*
			//Displaying the generated training set matrix
		    for(int i=0;i<c;i++){
		    
		        for(int j=0;j<noOfFeatures;j++)
		           { System.out.print(training_set[i][j]);
		            System.out.print("\t"); }
		            
		            System.out.print("\n");
		            
		    }    */
		    
		          
			for(Connection con : getConnections())
				{
					DTNHost other=con.getOtherNode(getHost());
					KMeansRouter othRouter = (KMeansRouter)other.getRouter();
					if(othRouter.isTransferring()){
						continue;
					}
					if(othRouter.hasMessage(m.getId())){
						continue;
					}

						messages.add(new Tuple<Message, Connection>(m,con));	
				} 
			
			
			
		}
		
		if (messages.size() == 0) {
			return null;
		}
		
	
		return tryMessagesForConnected(messages);	// try to send messages
	}




/**	
* Returns the current distance between dest node and the nextHost node
* @param dest The destination node 
* @param nextHost The node from which we want to calculate the diatance from
* @return the current distance
*/
private double getDistFor(DTNHost dest,DTNHost nextHost)
{
	Coord destLoc = dest.getLocation();
	Coord nextHostLoc = nextHost.getLocation();
	double x1 = nextHostLoc.getX();
	double y1 = nextHostLoc.getY();
	double x2 = destLoc.getX();
	double y2 = destLoc.getY();
	double a = y1 - y2;
	double b = x2 - x1;
	double c = y2*x1 - y1*x2;
	double dist = java.lang.Math.pow((a*a+b*b),0.5); 
	if(dist<0) dist = -dist;
	return dist;
}

	@Override
	public MessageRouter replicate() {
		KMeansRouter r = new KMeansRouter(this);
		return r;
	}

}
